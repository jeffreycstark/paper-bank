---
title: "Meaning of Democracy: Exploratory Analysis"
subtitle: "W3/W4/W6 Harmonization (2010-2022)"
author: "Jeffrey Stark"
date: today
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: true
    code-tools: true
    df-print: paged
    embed-resources: true
execute:
  warning: false
  message: false
---

# Overview

The Asian Barometer Survey includes a unique battery asking respondents to choose the "most essential characteristic of democracy" from sets of 4 options. Each set mixes **procedural** (elections, freedoms, rights) and **substantive** (economic welfare, governance quality) conceptions.

This analysis harmonizes W3/W4/W6 data to create a **procedural orientation index** (0-4) and explores:

1. Cross-national variation in democratic conceptions
2. Change over time (2010 → 2014 → 2019-2022)
3. Individual-level correlates (education, income, age, urban)
4. Potential "types" of democratic citizens

```{r setup}
library(tidyverse)
library(haven)
library(gt)
library(patchwork)
library(ggridges)

project_root <- "/Users/jeffreystark/Development/Research/econdev-authpref"
data_dir <- file.path(project_root, "data/processed")

# Load wave data
w3 <- readRDS(file.path(data_dir, "w3.rds"))
w4 <- readRDS(file.path(data_dir, "w4.rds"))
w6 <- readRDS(file.path(data_dir, "w6.rds"))

# Custom theme
theme_set(theme_minimal(base_size = 12) +
          theme(panel.grid.minor = element_blank(),
                legend.position = "bottom"))
```

# Data Extraction

## Identify Variables

First, let's confirm the variable names for each wave.

```{r identify-vars}
# Function to find democracy meaning vars
find_dem_vars <- function(df, pattern = "q8[5-8]|q9[0-1]") {
  names(df)[str_detect(tolower(names(df)), tolower(pattern))]
}

# Check what we have
cat("W3 variables matching pattern:\n")
w3_vars <- names(w3)[str_detect(tolower(names(w3)), "q8[5-8]")]
print(w3_vars)

cat("\nW4 variables matching pattern:\n")
w4_vars <- names(w4)[str_detect(tolower(names(w4)), "q8[8-9]|q9[0-1]")]
print(w4_vars)

cat("\nW6 variables matching pattern:\n")
w6_vars <- names(w6)[str_detect(tolower(names(w6)), "q8[5-8]")]
print(w6_vars)
```

```{r check-labels}
# Function to show value labels
show_labels <- function(df, var) {
  x <- df[[var]]
  if (haven::is.labelled(x)) {
    labels <- attr(x, "labels")
    tibble(value = labels, label = names(labels))
  } else {
    tibble(note = "Not labelled")
  }
}

# Check W6 Set 1 labels
cat("W6 q85 (Set 1) labels:\n")
show_labels(w6, "q85")
```

## Extract and Harmonize

Based on the codebook:
- **W3**: q85, q86, q87, q88 (Sets 1-4)
- **W4**: q88, q89, q90, q91 (Sets 1-4)
- **W6**: q85, q86, q87, q88 (Sets 1-4)

Each set has this structure:
- Set 1: 1=gap, 2=elections, 3=no waste, 4=expression → Procedural: 2, 4
- Set 2: 1=oversight, 2=basic needs, 3=organize, 4=services → Procedural: 1, 3
- Set 3: 1=law/order, 2=media, 3=jobs, 4=multiparty → Procedural: 2, 4
- Set 4: 1=protests, 2=corruption, 3=courts, 4=unemployment → Procedural: 1, 3

```{r harmonize-function}
# Recode to procedural (1) vs substantive (0)
recode_set1 <- function(x) {
  case_when(
    x %in% c(2, 4) ~ 1L,  # elections, expression = procedural
    x %in% c(1, 3) ~ 0L,  # gap, no waste = substantive
    TRUE ~ NA_integer_
  )
}

recode_set2 <- function(x) {
  case_when(
    x %in% c(1, 3) ~ 1L,  # oversight, organize = procedural
    x %in% c(2, 4) ~ 0L,  # basic needs, services = substantive
    TRUE ~ NA_integer_
  )
}

recode_set3 <- function(x) {
  case_when(
    x %in% c(2, 4) ~ 1L,  # media, multiparty = procedural
    x %in% c(1, 3) ~ 0L,  # law/order, jobs = substantive
    TRUE ~ NA_integer_
  )
}

recode_set4 <- function(x) {
  case_when(
    x %in% c(1, 3) ~ 1L,  # protests, courts = procedural
    x %in% c(2, 4) ~ 0L,  # corruption, unemployment = substantive
    TRUE ~ NA_integer_
  )
}
```

```{r extract-w3}
# W3: q85-q88
w3_dem <- w3 %>%
  select(
    country, 
    matches("^se[0-9]|^SE[0-9]"),  # demographics
    q85, q86, q87, q88
  ) %>%
  mutate(
    wave = "W3",
    wave_year = 2010,
    # Recode each set
    set1_proc = recode_set1(as.integer(q85)),
    set2_proc = recode_set2(as.integer(q86)),
    set3_proc = recode_set3(as.integer(q87)),
    set4_proc = recode_set4(as.integer(q88)),
    # Create procedural index (0-4)
    procedural_index = set1_proc + set2_proc + set3_proc + set4_proc,
    # Count valid responses
    n_valid = (!is.na(set1_proc)) + (!is.na(set2_proc)) + 
              (!is.na(set3_proc)) + (!is.na(set4_proc))
  )

cat("W3 extraction: ", nrow(w3_dem), "rows\n")
cat("Procedural index distribution:\n")
table(w3_dem$procedural_index, useNA = "ifany")
```

```{r extract-w4}
# W4: q88-q91
w4_dem <- w4 %>%
  select(
    country,
    matches("^se[0-9]|^SE[0-9]"),
    q88, q89, q90, q91
  ) %>%
  mutate(
    wave = "W4",
    wave_year = 2014,
    set1_proc = recode_set1(as.integer(q88)),
    set2_proc = recode_set2(as.integer(q89)),
    set3_proc = recode_set3(as.integer(q90)),
    set4_proc = recode_set4(as.integer(q91)),
    procedural_index = set1_proc + set2_proc + set3_proc + set4_proc,
    n_valid = (!is.na(set1_proc)) + (!is.na(set2_proc)) + 
              (!is.na(set3_proc)) + (!is.na(set4_proc))
  )

cat("W4 extraction: ", nrow(w4_dem), "rows\n")
cat("Procedural index distribution:\n")
table(w4_dem$procedural_index, useNA = "ifany")
```

```{r extract-w6}
# W6: q85-q88
w6_dem <- w6 %>%
  select(
    country,
    matches("^se[0-9]|^SE[0-9]"),
    q85, q86, q87, q88
  ) %>%
  mutate(
    wave = "W6",
    wave_year = 2020,
    set1_proc = recode_set1(as.integer(q85)),
    set2_proc = recode_set2(as.integer(q86)),
    set3_proc = recode_set3(as.integer(q87)),
    set4_proc = recode_set4(as.integer(q88)),
    procedural_index = set1_proc + set2_proc + set3_proc + set4_proc,
    n_valid = (!is.na(set1_proc)) + (!is.na(set2_proc)) + 
              (!is.na(set3_proc)) + (!is.na(set4_proc))
  )

cat("W6 extraction: ", nrow(w6_dem), "rows\n")
cat("Procedural index distribution:\n")
table(w6_dem$procedural_index, useNA = "ifany")
```

```{r combine-data}
# Get country names
get_country_name <- function(x) {
  if (haven::is.labelled(x)) {
    labels <- attr(x, "labels")
    names(labels)[match(as.integer(x), labels)]
  } else {
    as.character(x)
  }
}

# Combine waves
dem_panel <- bind_rows(
  w3_dem %>% mutate(country_code = as.integer(country)),
  w4_dem %>% mutate(country_code = as.integer(country)),
  w6_dem %>% mutate(country_code = as.integer(country))
) %>%
  mutate(
    country_name = case_when(
      country_code == 1 ~ "Japan",
      country_code == 2 ~ "South Korea",
      country_code == 3 ~ "Mongolia",
      country_code == 4 ~ "Taiwan",
      country_code == 5 ~ "Hong Kong",
      country_code == 6 ~ "China",
      country_code == 7 ~ "Philippines",
      country_code == 8 ~ "Thailand",
      country_code == 9 ~ "Vietnam",
      country_code == 10 ~ "Cambodia",
      country_code == 11 ~ "Singapore",
      country_code == 12 ~ "Myanmar",
      country_code == 13 ~ "Malaysia",
      country_code == 14 ~ "Indonesia",
      country_code == 15 ~ "India",
      TRUE ~ paste0("Unknown (", country_code, ")")
    )
  ) %>%
  # Filter to valid responses (at least 3 of 4 sets answered)
  filter(n_valid >= 3)

cat("Combined panel: ", nrow(dem_panel), "rows\n")
cat("\nCountries represented:\n")
table(dem_panel$country_name, dem_panel$wave)
```

# Analysis 1: Cross-National Variation

```{r country-means}
# Calculate mean procedural orientation by country and wave
country_wave_means <- dem_panel %>%
  group_by(country_name, wave, wave_year) %>%
  summarise(
    n = n(),
    mean_proc = mean(procedural_index, na.rm = TRUE),
    sd_proc = sd(procedural_index, na.rm = TRUE),
    se_proc = sd_proc / sqrt(n),
    pct_procedural = mean(procedural_index >= 3, na.rm = TRUE) * 100,
    .groups = "drop"
  ) %>%
  filter(n >= 100)  # Minimum sample size

country_wave_means %>%
  arrange(wave, desc(mean_proc)) %>%
  gt() %>%
  tab_header(title = "Procedural Orientation by Country and Wave") %>%
  fmt_number(columns = c(mean_proc, sd_proc, se_proc, pct_procedural), decimals = 2) %>%
  cols_label(
    mean_proc = "Mean (0-4)",
    sd_proc = "SD",
    se_proc = "SE",
    pct_procedural = "% High Procedural"
  )
```

```{r country-plot, fig.width=12, fig.height=8}
# Dot plot with confidence intervals
country_wave_means %>%
  ggplot(aes(x = mean_proc, y = reorder(country_name, mean_proc), color = wave)) +
  geom_point(size = 3, position = position_dodge(width = 0.5)) +
  geom_errorbarh(aes(xmin = mean_proc - 1.96*se_proc, 
                     xmax = mean_proc + 1.96*se_proc),
                 height = 0.2, position = position_dodge(width = 0.5)) +
  geom_vline(xintercept = 2, linetype = "dashed", alpha = 0.5) +
  scale_color_brewer(palette = "Set1") +
  labs(
    x = "Mean Procedural Index (0-4)",
    y = NULL,
    title = "What Does Democracy Mean? Procedural vs. Substantive Conceptions",
    subtitle = "Higher values = prioritize elections, freedoms, rights over economic outcomes",
    color = "Wave",
    caption = "Vertical line at 2 = equal procedural/substantive orientation"
  ) +
  theme(legend.position = "right")
```

```{r ridge-plot, fig.width=10, fig.height=10}
# Ridge plot showing full distributions
dem_panel %>%
  filter(!is.na(procedural_index)) %>%
  ggplot(aes(x = procedural_index, y = reorder(country_name, procedural_index, mean), 
             fill = wave)) +
  geom_density_ridges(alpha = 0.6, scale = 1.5) +
  scale_fill_brewer(palette = "Set1") +
  scale_x_continuous(breaks = 0:4) +
  labs(
    x = "Procedural Index (0 = fully substantive, 4 = fully procedural)",
    y = NULL,
    title = "Distribution of Democratic Conceptions by Country",
    fill = "Wave"
  )
```

# Analysis 2: Change Over Time

```{r time-trends}
# Calculate overall trend by country
time_trends <- country_wave_means %>%
  group_by(country_name) %>%
  filter(n() >= 2) %>%  # Need at least 2 waves
  arrange(wave_year) %>%
  mutate(
    change = mean_proc - first(mean_proc),
    first_wave = first(wave),
    last_wave = last(wave)
  ) %>%
  ungroup()

# Countries with biggest changes
change_summary <- time_trends %>%
  filter(wave == last_wave) %>%
  select(country_name, first_wave, last_wave, change) %>%
  arrange(desc(abs(change)))

change_summary %>%
  gt() %>%
  tab_header(title = "Change in Procedural Orientation Over Time") %>%
  fmt_number(columns = change, decimals = 3)
```

```{r slopegraph, fig.width=10, fig.height=8}
# Slope graph showing change
time_trends %>%
  ggplot(aes(x = wave_year, y = mean_proc, group = country_name, color = country_name)) +
  geom_line(linewidth = 1) +
  geom_point(size = 3) +
  geom_text(data = time_trends %>% filter(wave == "W3"),
            aes(label = country_name), hjust = 1.1, size = 3) +
  scale_x_continuous(breaks = c(2010, 2014, 2020)) +
  labs(
    x = "Year",
    y = "Mean Procedural Index",
    title = "Trajectories of Democratic Conceptions (2010-2020)",
    subtitle = "Which countries are becoming more procedural? More substantive?"
  ) +
  theme(legend.position = "none")
```

# Analysis 3: Set-by-Set Breakdown

Let's see which specific tradeoffs drive the overall patterns.

```{r set-breakdown}
# Calculate procedural % for each set
set_breakdown <- dem_panel %>%
  group_by(country_name, wave) %>%
  summarise(
    n = n(),
    set1_pct = mean(set1_proc, na.rm = TRUE) * 100,  # elections/expression vs gap/waste
    set2_pct = mean(set2_proc, na.rm = TRUE) * 100,  # oversight/organize vs needs/services
    set3_pct = mean(set3_proc, na.rm = TRUE) * 100,  # media/multiparty vs law/jobs
    set4_pct = mean(set4_proc, na.rm = TRUE) * 100,  # protests/courts vs corruption/unemploy
    .groups = "drop"
  ) %>%
  filter(n >= 100)

# Reshape for plotting
set_breakdown_long <- set_breakdown %>%
  pivot_longer(cols = starts_with("set"), names_to = "set", values_to = "pct_procedural") %>%
  mutate(
    set_label = case_when(
      set == "set1_pct" ~ "Set 1:\nElections/Expression\nvs Gap/No waste",
      set == "set2_pct" ~ "Set 2:\nOversight/Organize\nvs Needs/Services",
      set == "set3_pct" ~ "Set 3:\nMedia/Multiparty\nvs Law&Order/Jobs",
      set == "set4_pct" ~ "Set 4:\nProtests/Courts\nvs Corruption/Unemploy"
    )
  )
```

```{r set-heatmap, fig.width=12, fig.height=10}
# Heatmap of set-by-set results
set_breakdown_long %>%
  filter(wave == "W6") %>%  # Focus on most recent
  ggplot(aes(x = set_label, y = reorder(country_name, pct_procedural), fill = pct_procedural)) +
  geom_tile(color = "white") +
  geom_text(aes(label = round(pct_procedural, 0)), size = 3) +
  scale_fill_gradient2(low = "#d73027", mid = "#ffffbf", high = "#1a9850", 
                       midpoint = 50, limits = c(0, 100)) +
  labs(
    x = NULL,
    y = NULL,
    fill = "% Procedural",
    title = "Procedural Choice by Set (W6, 2019-2022)",
    subtitle = "Values > 50% = majority chose procedural option"
  ) +
  theme(axis.text.x = element_text(size = 8))
```

```{r set-variation}
# Which sets show most variation across countries?
set_variation <- set_breakdown_long %>%
  filter(wave == "W6") %>%
  group_by(set, set_label) %>%
  summarise(
    mean_pct = mean(pct_procedural, na.rm = TRUE),
    sd_pct = sd(pct_procedural, na.rm = TRUE),
    min_pct = min(pct_procedural, na.rm = TRUE),
    max_pct = max(pct_procedural, na.rm = TRUE),
    range = max_pct - min_pct,
    .groups = "drop"
  ) %>%
  arrange(desc(range))

set_variation %>%
  gt() %>%
  tab_header(
    title = "Cross-National Variation by Question Set",
    subtitle = "Which tradeoffs produce most disagreement?"
  ) %>%
  fmt_number(columns = c(mean_pct, sd_pct, min_pct, max_pct, range), decimals = 1)
```

# Analysis 4: Individual-Level Correlates

```{r add-demographics}
# We need to extract demographics - let's check what's available
cat("Checking for demographic variables...\n")

# Common demographic variable patterns in ABS
demo_patterns <- c("se2", "se3", "se5", "se6", "se9", "se14")

# Check W6
cat("\nW6 demographic vars:\n")
w6_demo_vars <- names(w6)[str_detect(tolower(names(w6)), paste(demo_patterns, collapse = "|"))]
print(head(w6_demo_vars, 20))
```

```{r extract-demos-w6}
# Extract key demographics from W6 (most complete data)
# Standard ABS coding:
# se2 = gender (1=male, 2=female)
# se3 = birth year -> age
# se5 = education
# se6 = income
# se14 = urban/rural

w6_with_demos <- w6 %>%
  select(
    country, q85, q86, q87, q88,
    matches("^se2$|^SE2$"),   # gender
    matches("^se3|^SE3"),     # birth year
    matches("^se5|^SE5"),     # education
    matches("^se14|^SE14")    # urban
  ) %>%
  rename_with(tolower) %>%
  mutate(
    wave = "W6",
    set1_proc = recode_set1(as.integer(q85)),
    set2_proc = recode_set2(as.integer(q86)),
    set3_proc = recode_set3(as.integer(q87)),
    set4_proc = recode_set4(as.integer(q88)),
    procedural_index = set1_proc + set2_proc + set3_proc + set4_proc,
    country_code = as.integer(country),
    country_name = case_when(
      country_code == 1 ~ "Japan",
      country_code == 2 ~ "South Korea",
      country_code == 3 ~ "Mongolia",
      country_code == 4 ~ "Taiwan",
      country_code == 5 ~ "Hong Kong",
      country_code == 6 ~ "China",
      country_code == 7 ~ "Philippines",
      country_code == 8 ~ "Thailand",
      country_code == 9 ~ "Vietnam",
      country_code == 10 ~ "Cambodia",
      country_code == 11 ~ "Singapore",
      country_code == 12 ~ "Myanmar",
      country_code == 13 ~ "Malaysia",
      country_code == 14 ~ "Indonesia",
      TRUE ~ NA_character_
    )
  )

# Check what we got
cat("Variables in w6_with_demos:\n")
names(w6_with_demos)
```

```{r demographic-analysis}
# Attempt to create standardized demographics
# This will depend on what variables are available

# Check for education variable
if ("se5" %in% names(w6_with_demos)) {
  cat("Education distribution:\n")
  print(table(w6_with_demos$se5, useNA = "ifany"))
}

# For now, let's just look at country-level patterns
# More detailed demographic analysis would require careful variable harmonization
```

# Key Findings (Preliminary)

```{r summary-stats}
# Overall summary
overall_summary <- dem_panel %>%
  group_by(wave) %>%
  summarise(
    n = n(),
    n_countries = n_distinct(country_name),
    mean_proc = mean(procedural_index, na.rm = TRUE),
    sd_proc = sd(procedural_index, na.rm = TRUE),
    pct_high_proc = mean(procedural_index >= 3, na.rm = TRUE) * 100,
    pct_low_proc = mean(procedural_index <= 1, na.rm = TRUE) * 100,
    .groups = "drop"
  )

overall_summary %>%
  gt() %>%
  tab_header(title = "Overall Summary by Wave") %>%
  fmt_number(columns = c(mean_proc, sd_proc, pct_high_proc, pct_low_proc), decimals = 2)
```

## Preliminary Observations

Based on this exploratory analysis:

1. **Substantial cross-national variation**: Some countries (TBD) consistently prioritize procedural democracy, while others prioritize substantive outcomes.

2. **Temporal trends**: (TBD based on data)

3. **Set-specific patterns**: Different tradeoffs produce different levels of consensus. Some choices (e.g., elections vs. income gap) may be more contested than others.

4. **Potential "types"**: The distribution of the 0-4 index may reveal distinct clusters of democratic citizens.

## Next Steps

1. Add demographic predictors (education, income, age, urban)
2. Run multilevel models with country random effects
3. Explore latent class analysis for citizen typologies
4. Connect to behavioral outcomes (protest, voting, trust)

# Session Info

```{r session}
sessionInfo()
```
