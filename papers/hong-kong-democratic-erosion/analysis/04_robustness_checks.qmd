---
title: "04 - Robustness Checks"
subtitle: "Mann-Whitney U Tests, Demographic Balance, and Stratified Bootstrap"
format: html
execute:
  echo: true
  warning: false
  message: false
  cache: true
---

```{r setup}
library(tidyverse)
library(knitr)
library(kableExtra)
library(boot)
```

# Load Prepared Data

```{r load-data}
load("results/prepared_data.RData")

# Analytical sample: Protest vs Post-NSL only
hk5_analysis <- hk5 |>
  filter(period %in% c("Protest", "Post-NSL")) |>
  mutate(period = droplevels(period))

cat("Protest:", sum(hk5_analysis$period == "Protest"),
    "| Post-NSL:", sum(hk5_analysis$period == "Post-NSL"), "\n")
```

# 1. Mann-Whitney U Tests

Cross-validate the parametric t-tests with non-parametric Wilcoxon rank-sum
(Mann-Whitney U) tests. This guards against violations of normality assumptions,
which are plausible given that many trust indicators are measured on short
ordinal scales (1–4).

```{r mann-whitney}
# Variables used in the main NSL comparison
nsl_vars <- c(
  # Democratic evaluation
  "democracy_suitability", "dem_extent_current", "dem_country_present_govt",
  # Democratic commitment
  "dem_always_preferable", "democracy_satisfaction",
  # Institutional trust
  "trust_national_government", "trust_president", "trust_parliament",
  "trust_police", "trust_military", "trust_courts",
  # Governance perceptions
  "gov_free_to_organize", "dem_free_speech", "govt_responds_people",
  "election_free_fair",
  # System support
  "system_deserves_support", "system_proud", "system_needs_change",
  # Authoritarian alternatives
  "strongman_rule", "military_rule", "single_party_rule"
)
nsl_vars <- nsl_vars[nsl_vars %in% names(hk5_analysis)]

# Run both t-tests and Mann-Whitney U for each variable
mw_results <- map_dfr(nsl_vars, function(var) {
  protest <- hk5_analysis |> filter(period == "Protest") |> pull(!!sym(var)) |> na.omit()
  postnsl <- hk5_analysis |> filter(period == "Post-NSL") |> pull(!!sym(var)) |> na.omit()

  if (length(protest) < 10 | length(postnsl) < 10) return(NULL)

  # Parametric t-test
  tt <- t.test(protest, postnsl)

  # Non-parametric Mann-Whitney U
  wt <- wilcox.test(protest, postnsl, exact = FALSE)

  # Cohen's d
  pooled_sd <- sqrt(((length(protest) - 1) * sd(protest)^2 +
                       (length(postnsl) - 1) * sd(postnsl)^2) /
                      (length(protest) + length(postnsl) - 2))
  d <- (mean(postnsl) - mean(protest)) / pooled_sd

  tibble(
    variable = var,
    protest_mean = mean(protest),
    postnsl_mean = mean(postnsl),
    cohens_d = d,
    t_stat = tt$statistic,
    t_p = tt$p.value,
    t_sig = case_when(tt$p.value < 0.001 ~ "***",
                      tt$p.value < 0.01  ~ "**",
                      tt$p.value < 0.05  ~ "*",
                      TRUE ~ ""),
    mw_stat = wt$statistic,
    mw_p = wt$p.value,
    mw_sig = case_when(wt$p.value < 0.001 ~ "***",
                       wt$p.value < 0.01  ~ "**",
                       wt$p.value < 0.05  ~ "*",
                       TRUE ~ ""),
    agree = (t_sig == mw_sig) | (tt$p.value < 0.05 & wt$p.value < 0.05)
  )
})

mw_results |>
  select(variable, cohens_d, t_p, t_sig, mw_p, mw_sig, agree) |>
  mutate(across(c(cohens_d), ~round(.x, 3)),
         t_p = format.pval(t_p, digits = 3),
         mw_p = format.pval(mw_p, digits = 3)) |>
  kable(
    col.names = c("Variable", "Cohen's d", "t p-value", "", "MW p-value", "", "Agree?"),
    caption = "Parametric (t-test) vs Non-parametric (Mann-Whitney U) comparison",
    booktabs = TRUE
  ) |>
  kable_styling(latex_options = c("scale_down", "hold_position"))
```

```{r mw-summary}
n_vars <- nrow(mw_results)
n_agree <- sum(mw_results$agree)
cat("Agreement between t-test and Mann-Whitney U:", n_agree, "of", n_vars, "variables",
    paste0("(", round(100 * n_agree / n_vars, 1), "%)\n"))

# Flag any variables where conclusions diverge
divergent <- mw_results |> filter(!agree)
if (nrow(divergent) > 0) {
  cat("\nDivergent results:\n")
  print(divergent |> select(variable, cohens_d, t_p, mw_p))
} else {
  cat("No divergent results: parametric and non-parametric tests yield consistent conclusions.\n")
}
```


# 2. Demographic Balance Across Periods

Assess whether compositional selection drives the observed attitudinal shifts
by comparing the demographic profile of the Protest and Post-NSL sub-samples.

```{r demographic-balance}
# --- Age ---
age_balance <- hk5_analysis |>
  filter(!is.na(age)) |>
  group_by(period) |>
  summarise(
    mean_age = mean(age, na.rm = TRUE),
    sd_age = sd(age, na.rm = TRUE),
    n = n(),
    .groups = "drop"
  )

age_test <- t.test(age ~ period, data = hk5_analysis)
age_mw <- wilcox.test(age ~ period, data = hk5_analysis, exact = FALSE)

cat("=== Age ===\n")
print(age_balance)
cat("t-test p =", format.pval(age_test$p.value, digits = 3),
    "| MW p =", format.pval(age_mw$p.value, digits = 3), "\n\n")

# --- Age group distribution ---
age_group_table <- hk5_analysis |>
  filter(!is.na(age_group)) |>
  count(period, age_group) |>
  group_by(period) |>
  mutate(prop = n / sum(n)) |>
  ungroup()

age_chi <- chisq.test(table(hk5_analysis$period, hk5_analysis$age_group))

cat("=== Age Group Distribution ===\n")
age_group_table |>
  select(-n) |>
  pivot_wider(names_from = period, values_from = prop) |>
  mutate(across(where(is.numeric), ~round(.x, 3))) |>
  kable(caption = "Age group proportions by period") |>
  print()
cat("Chi-squared p =", format.pval(age_chi$p.value, digits = 3), "\n\n")

# --- Gender ---
if ("female" %in% names(hk5_analysis)) {
  gender_table <- hk5_analysis |>
    filter(!is.na(female)) |>
    count(period, female) |>
    group_by(period) |>
    mutate(prop = n / sum(n)) |>
    ungroup()

  gender_chi <- chisq.test(table(hk5_analysis$period, hk5_analysis$female))

  cat("=== Gender ===\n")
  gender_table |>
    select(-n) |>
    pivot_wider(names_from = period, values_from = prop) |>
    mutate(across(where(is.numeric), ~round(.x, 3))) |>
    kable(caption = "Gender proportions by period") |>
    print()
  cat("Chi-squared p =", format.pval(gender_chi$p.value, digits = 3), "\n\n")
} else if ("gender" %in% names(hk5_analysis)) {
  gender_table <- hk5_analysis |>
    filter(!is.na(gender)) |>
    count(period, gender) |>
    group_by(period) |>
    mutate(prop = n / sum(n)) |>
    ungroup()

  gender_chi <- chisq.test(table(hk5_analysis$period, hk5_analysis$gender))

  cat("=== Gender ===\n")
  gender_table |>
    select(-n) |>
    pivot_wider(names_from = period, values_from = prop) |>
    mutate(across(where(is.numeric), ~round(.x, 3))) |>
    kable(caption = "Gender proportions by period") |>
    print()
  cat("Chi-squared p =", format.pval(gender_chi$p.value, digits = 3), "\n\n")
}

# --- Education ---
# Determine which education variable to use: education_level (SE5, ordinal 1-10),
# education_years (continuous), or generic "education"
edu_var <- NULL
if ("education_level" %in% names(hk5_analysis)) {
  # Clean education_level: recode 97/98/99/11/-1 to NA
  hk5_analysis <- hk5_analysis |>
    mutate(
      education_level_clean = case_when(
        education_level %in% c(-1, 11, 97, 98, 99) ~ NA_real_,
        TRUE ~ as.numeric(education_level)
      )
    )
  if (sum(!is.na(hk5_analysis$education_level_clean)) > 100) {
    edu_var <- "education_level_clean"
  }
}
if (is.null(edu_var) && "education_years" %in% names(hk5_analysis) &&
    sum(!is.na(hk5_analysis$education_years)) > 100) {
  edu_var <- "education_years"
}
if (is.null(edu_var) && "education" %in% names(hk5_analysis) &&
    sum(!is.na(hk5_analysis$education)) > 100) {
  edu_var <- "education"
}

edu_test <- NULL
if (!is.null(edu_var)) {
  edu_balance <- hk5_analysis |>
    filter(!is.na(!!sym(edu_var))) |>
    group_by(period) |>
    summarise(
      mean_edu = mean(!!sym(edu_var), na.rm = TRUE),
      sd_edu = sd(!!sym(edu_var), na.rm = TRUE),
      n = n(),
      .groups = "drop"
    )

  edu_test <- t.test(as.formula(paste(edu_var, "~ period")), data = hk5_analysis)
  edu_mw <- wilcox.test(as.formula(paste(edu_var, "~ period")),
                        data = hk5_analysis, exact = FALSE)

  cat("=== Education (", edu_var, ") ===\n")
  print(edu_balance)
  cat("t-test p =", format.pval(edu_test$p.value, digits = 3),
      "| MW p =", format.pval(edu_mw$p.value, digits = 3), "\n\n")
} else {
  cat("=== Education: no suitable variable found ===\n")
}
```

```{r balance-summary-table}
# Compile a clean balance table for manuscript appendix
balance_rows <- list()

# Age (continuous)
balance_rows$age <- tibble(
  covariate = "Age (mean)",
  protest = age_balance$mean_age[age_balance$period == "Protest"],
  postnsl = age_balance$mean_age[age_balance$period == "Post-NSL"],
  test = "t-test",
  p_value = age_test$p.value
)

# Gender (if available)
if ("female" %in% names(hk5_analysis)) {
  fem_prop <- hk5_analysis |>
    filter(!is.na(female)) |>
    group_by(period) |>
    summarise(prop_female = mean(female, na.rm = TRUE), .groups = "drop")
  balance_rows$gender <- tibble(
    covariate = "Female (%)",
    protest = fem_prop$prop_female[fem_prop$period == "Protest"] * 100,
    postnsl = fem_prop$prop_female[fem_prop$period == "Post-NSL"] * 100,
    test = "Chi-squared",
    p_value = gender_chi$p.value
  )
} else if ("gender" %in% names(hk5_analysis)) {
  # Adapt if gender is coded differently
  gender_summary <- hk5_analysis |>
    filter(!is.na(gender)) |>
    group_by(period) |>
    summarise(modal_gender = names(sort(table(gender), decreasing = TRUE))[1],
              .groups = "drop")
  balance_rows$gender <- tibble(
    covariate = "Gender distribution",
    protest = NA_real_,
    postnsl = NA_real_,
    test = "Chi-squared",
    p_value = gender_chi$p.value
  )
}

# Education (using whichever variable was found above)
if (!is.null(edu_test)) {
  edu_label <- ifelse(edu_var == "education_level_clean",
                      "Education level (SE5, ordinal 1-10)",
                      ifelse(edu_var == "education_years",
                             "Education (years)",
                             "Education (mean)"))
  balance_rows$edu <- tibble(
    covariate = edu_label,
    protest = edu_balance$mean_edu[edu_balance$period == "Protest"],
    postnsl = edu_balance$mean_edu[edu_balance$period == "Post-NSL"],
    test = "t-test",
    p_value = edu_test$p.value
  )
}

# Age group distribution
balance_rows$age_group <- tibble(
  covariate = "Age group distribution",
  protest = NA_real_,
  postnsl = NA_real_,
  test = "Chi-squared",
  p_value = age_chi$p.value
)

balance_table <- bind_rows(balance_rows) |>
  mutate(
    across(c(protest, postnsl), ~round(.x, 2)),
    p_value = format.pval(p_value, digits = 3),
    sig = case_when(
      as.numeric(gsub("<", "", p_value)) < 0.001 ~ "***",
      as.numeric(gsub("<", "", p_value)) < 0.01  ~ "**",
      as.numeric(gsub("<", "", p_value)) < 0.05  ~ "*",
      TRUE ~ ""
    )
  )

balance_table |>
  kable(
    col.names = c("Covariate", "Protest", "Post-NSL", "Test", "p-value", ""),
    caption = "Demographic balance across fieldwork periods",
    booktabs = TRUE
  ) |>
  kable_styling(latex_options = c("hold_position"))
```


# 3. Stratified Percentile Bootstrap

Resample independently within each period to preserve the quasi-experimental
structure. Report BCa 95% confidence intervals for the mean difference
(Post-NSL − Protest) and Cohen's d for each variable.

```{r bootstrap}
set.seed(42)
n_boot <- 5000

# --- Parallel setup ---
if (!requireNamespace("future", quietly = TRUE)) install.packages("future", repos = "https://cran.r-project.org")
if (!requireNamespace("furrr", quietly = TRUE)) install.packages("furrr", repos = "https://cran.r-project.org")
library(future)
library(furrr)

n_cores <- max(1L, parallel::detectCores(logical = FALSE) - 1L)
plan(multisession, workers = n_cores)
cat("Bootstrap running on", n_cores, "parallel workers\n")

# Function to compute mean difference for a single variable
boot_mean_diff <- function(data, indices, var, period_var = "period") {
  boot_data <- data[indices, ]
  protest_mean <- mean(boot_data[[var]][boot_data[[period_var]] == "Protest"], na.rm = TRUE)
  postnsl_mean <- mean(boot_data[[var]][boot_data[[period_var]] == "Post-NSL"], na.rm = TRUE)
  postnsl_mean - protest_mean
}

# Function to compute Cohen's d
boot_cohens_d <- function(data, indices, var, period_var = "period") {
  boot_data <- data[indices, ]
  protest <- boot_data[[var]][boot_data[[period_var]] == "Protest"]
  postnsl <- boot_data[[var]][boot_data[[period_var]] == "Post-NSL"]
  protest <- protest[!is.na(protest)]
  postnsl <- postnsl[!is.na(postnsl)]

  if (length(protest) < 5 | length(postnsl) < 5) return(NA_real_)

  pooled_sd <- sqrt(((length(protest) - 1) * sd(protest)^2 +
                       (length(postnsl) - 1) * sd(postnsl)^2) /
                      (length(protest) + length(postnsl) - 2))
  if (pooled_sd == 0) return(NA_real_)
  (mean(postnsl) - mean(protest)) / pooled_sd
}

# Stratified bootstrap for a single variable (self-contained for worker export)
boot_stratified <- function(var, data, R, seed_offset = 0L) {
  library(boot)
  set.seed(42L + seed_offset)

  protest_vals <- data[data$period == "Protest" & !is.na(data[[var]]), var, drop = TRUE]
  postnsl_vals <- data[data$period == "Post-NSL" & !is.na(data[[var]]), var, drop = TRUE]

  if (length(protest_vals) < 10 | length(postnsl_vals) < 10) return(NULL)

  sub <- data[!is.na(data[[var]]), ]
  strata_int <- as.integer(factor(sub$period))

  boot_mean_diff_local <- function(d, i, v) {
    bd <- d[i, ]
    mean(bd[[v]][bd$period == "Post-NSL"], na.rm = TRUE) -
      mean(bd[[v]][bd$period == "Protest"], na.rm = TRUE)
  }

  boot_cohens_d_local <- function(d, i, v) {
    bd <- d[i, ]
    p <- bd[[v]][bd$period == "Protest"]; p <- p[!is.na(p)]
    q <- bd[[v]][bd$period == "Post-NSL"]; q <- q[!is.na(q)]
    if (length(p) < 5 | length(q) < 5) return(NA_real_)
    ps <- sqrt(((length(p)-1)*sd(p)^2 + (length(q)-1)*sd(q)^2) / (length(p)+length(q)-2))
    if (ps == 0) return(NA_real_)
    (mean(q) - mean(p)) / ps
  }

  boot_diff <- boot(data = sub, statistic = boot_mean_diff_local, R = R,
                    strata = strata_int, v = var)
  boot_d   <- boot(data = sub, statistic = boot_cohens_d_local, R = R,
                    strata = strata_int, v = var)

  extract_ci <- function(b) {
    ci <- tryCatch(boot.ci(b, type = "bca", conf = 0.95),
                   error = function(e) tryCatch(boot.ci(b, type = "perc", conf = 0.95),
                                                error = function(e2) NULL))
    if (!is.null(ci$bca))     return(list(lo = ci$bca[4], hi = ci$bca[5], type = "BCa"))
    if (!is.null(ci$percent)) return(list(lo = ci$percent[4], hi = ci$percent[5], type = "Percentile"))
    list(lo = NA_real_, hi = NA_real_, type = "Failed")
  }

  ci_diff <- extract_ci(boot_diff)
  ci_d    <- extract_ci(boot_d)

  tibble::tibble(
    variable     = var,
    observed_diff = boot_diff$t0,
    boot_diff_lo  = ci_diff$lo,
    boot_diff_hi  = ci_diff$hi,
    observed_d    = boot_d$t0,
    boot_d_lo     = ci_d$lo,
    boot_d_hi     = ci_d$hi,
    ci_type       = ci_diff$type,
    sig_boot      = !(ci_diff$lo <= 0 & ci_diff$hi >= 0)
  )
}

# Run bootstrap in parallel across variables
tstart <- Sys.time()
boot_results <- future_map_dfr(
  seq_along(nsl_vars),
  function(i) boot_stratified(nsl_vars[i], data = hk5_analysis, R = n_boot, seed_offset = i),
  .options = furrr_options(seed = TRUE),
  .progress = TRUE
)
tend <- Sys.time()
cat("Bootstrap completed in", round(difftime(tend, tstart, units = "secs"), 1), "seconds\n")

# Reset to sequential
plan(sequential)
```

```{r bootstrap-table}
boot_results |>
  mutate(across(where(is.numeric), ~round(.x, 3))) |>
  kable(
    col.names = c("Variable", "Obs. Diff", "Diff CI Lo", "Diff CI Hi",
                   "Obs. d", "d CI Lo", "d CI Hi", "CI Type", "Sig?"),
    caption = "Stratified bootstrap results (5,000 iterations): BCa 95% confidence intervals",
    booktabs = TRUE
  ) |>
  kable_styling(latex_options = c("scale_down", "hold_position"))
```

```{r bootstrap-summary}
n_sig <- sum(boot_results$sig_boot, na.rm = TRUE)
n_total <- nrow(boot_results)
cat("Bootstrap significance:", n_sig, "of", n_total, "variables have CIs excluding zero",
    paste0("(", round(100 * n_sig / n_total, 1), "%)\n"))

# Highlight trust variables specifically
trust_boot <- boot_results |>
  filter(str_detect(variable, "trust"))
cat("\nTrust variable bootstrap CIs:\n")
trust_boot |>
  select(variable, observed_d, boot_d_lo, boot_d_hi, sig_boot) |>
  mutate(across(where(is.numeric), ~round(.x, 3))) |>
  print()
```

```{r}
#| label: fig-bootstrap-forest
#| fig-cap: "Stratified bootstrap 95% BCa confidence intervals for Cohen's d (Post-NSL − Protest). Positive values indicate higher post-NSL responses. Variables where the CI excludes zero are shown in colour."
#| fig-width: 10
#| fig-height: 8

boot_results |>
  mutate(
    variable = str_replace_all(variable, "_", " ") |> str_to_title(),
    sig_label = ifelse(sig_boot, "Significant", "Not significant")
  ) |>
  ggplot(aes(x = observed_d, y = reorder(variable, observed_d), color = sig_label)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey50") +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = boot_d_lo, xmax = boot_d_hi), height = 0.25) +
  scale_color_manual(values = c("Significant" = "#E53935", "Not significant" = "#9E9E9E")) +
  labs(
    x = "Cohen's d (Post-NSL − Protest)",
    y = NULL,
    color = NULL
  ) +
  theme_minimal(base_size = 11) +
  theme(legend.position = "bottom")
```


# 4. Age-Stratified Pre/Post Shifts

Faceted bar chart showing the pre/post shift within each age cohort for key
variables. This addresses whether the trust increase is driven entirely by
older cohorts (compositional) or appears across all age groups (more consistent
with falsification).

```{r}
#| label: fig-age-stratified
#| fig-cap: "Pre/Post NSL mean shifts within age cohorts for trust in police and democracy suitability. Error bars show 95% confidence intervals."
#| fig-width: 12
#| fig-height: 7

age_strat_vars <- c("trust_police", "democracy_suitability", 
                     "trust_national_government", "gov_free_to_organize")

age_strat_labels <- c(
  trust_police = "Trust in Police",
  democracy_suitability = "Democracy Suitability",
  trust_national_government = "Trust in Government",
  gov_free_to_organize = "Freedom to Organize"
)

age_strat_data <- hk5_analysis |>
  filter(!is.na(age_group)) |>
  pivot_longer(cols = all_of(age_strat_vars), names_to = "variable", values_to = "value") |>
  filter(!is.na(value)) |>
  group_by(variable, period, age_group) |>
  summarise(
    mean = mean(value),
    se = sd(value) / sqrt(n()),
    n = n(),
    .groups = "drop"
  ) |>
  mutate(var_label = age_strat_labels[variable])

ggplot(age_strat_data, aes(x = age_group, y = mean, fill = period)) +
  geom_col(position = position_dodge(0.8), width = 0.7, alpha = 0.85) +
  geom_errorbar(aes(ymin = mean - 1.96 * se, ymax = mean + 1.96 * se),
                position = position_dodge(0.8), width = 0.25) +
  facet_wrap(~var_label, scales = "free_y", ncol = 2) +
  scale_fill_manual(values = c("Protest" = "#FF7043", "Post-NSL" = "#5C6BC0")) +
  labs(
    x = "Age Cohort", y = "Mean", fill = NULL,
    title = "Pre/Post NSL Shifts Within Age Cohorts"
  ) +
  theme_minimal(base_size = 11) +
  theme(legend.position = "bottom",
        axis.text.x = element_text(angle = 45, hjust = 1))
```


# 5. Informal Manski-Style Bounds

Worst-case bounding exercise: if all non-respondents in the post-NSL period
would have reported the minimum possible trust score, what would the adjusted
mean be? This provides a lower bound on the trust increase.

```{r manski-bounds}
# Generalized Manski bounds function for any trust variable
# R2 requested: extend bounds to at least trust_national_government in addition to police

compute_manski_bounds <- function(data, var, var_label, min_score = 1) {
  protest_vals <- data |>
    filter(period == "Protest", !is.na(!!sym(var))) |>
    pull(!!sym(var))
  postnsl_vals <- data |>
    filter(period == "Post-NSL", !is.na(!!sym(var))) |>
    pull(!!sym(var))

  observed_postnsl_mean <- mean(postnsl_vals)
  observed_protest_mean <- mean(protest_vals)

  scenarios <- tibble(pct_missing_critics = seq(0, 40, by = 5)) |>
    mutate(
      variable = var_label,
      n_observed = length(postnsl_vals),
      n_missing = round(n_observed * pct_missing_critics / 100),
      adjusted_mean = (sum(postnsl_vals) + n_missing * min_score) / (n_observed + n_missing),
      protest_mean = observed_protest_mean,
      trust_still_higher = adjusted_mean > observed_protest_mean
    )

  scenarios
}

# Trust in police
manski_police <- compute_manski_bounds(hk5_analysis, "trust_police", "Trust in Police")

# Trust in national government (R2 requested expansion)
manski_govt <- compute_manski_bounds(hk5_analysis, "trust_national_government",
                                      "Trust in Nat'l Government")

# Combine
manski_scenarios <- bind_rows(manski_police, manski_govt)

# Display trust in police
manski_police |>
  mutate(across(c(adjusted_mean, protest_mean), ~round(.x, 3))) |>
  select(pct_missing_critics, n_observed, n_missing, adjusted_mean, trust_still_higher) |>
  kable(
    col.names = c("% Missing Critics", "N Observed", "N Missing (imputed)",
                   "Adjusted Post-NSL Mean", "Still > Protest Mean?"),
    caption = paste0("Manski-style worst-case bounds for TRUST IN POLICE. ",
                     "Protest mean = ", round(manski_police$protest_mean[1], 3),
                     "; Observed post-NSL mean = ",
                     round(mean(hk5_analysis$trust_police[hk5_analysis$period == "Post-NSL"], na.rm = TRUE), 3)),
    booktabs = TRUE
  ) |>
  kable_styling(latex_options = c("hold_position"))

cat("\nTrust in police: increase disappears at approximately",
    manski_police |> filter(!trust_still_higher) |> slice_min(pct_missing_critics) |> pull(pct_missing_critics),
    "% missing critics.\n")

# Display trust in national government
manski_govt |>
  mutate(across(c(adjusted_mean, protest_mean), ~round(.x, 3))) |>
  select(pct_missing_critics, n_observed, n_missing, adjusted_mean, trust_still_higher) |>
  kable(
    col.names = c("% Missing Critics", "N Observed", "N Missing (imputed)",
                   "Adjusted Post-NSL Mean", "Still > Protest Mean?"),
    caption = paste0("Manski-style worst-case bounds for TRUST IN NATIONAL GOVERNMENT. ",
                     "Protest mean = ", round(manski_govt$protest_mean[1], 3),
                     "; Observed post-NSL mean = ",
                     round(mean(hk5_analysis$trust_national_government[hk5_analysis$period == "Post-NSL"], na.rm = TRUE), 3)),
    booktabs = TRUE
  ) |>
  kable_styling(latex_options = c("hold_position"))

cat("\nTrust in national government: increase disappears at approximately",
    manski_govt |> filter(!trust_still_higher) |> slice_min(pct_missing_critics) |> pull(pct_missing_critics),
    "% missing critics.\n")
```


# 6. Save Results

```{r save-robustness}
save(mw_results, balance_table, boot_results, manski_scenarios,
     file = "results/robustness_results.RData")
cat("Robustness results saved to results/robustness_results.RData\n")
```
