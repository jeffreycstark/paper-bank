---
title: "04 - Robustness Checks"
subtitle: "Mann-Whitney U Tests, Demographic Balance, and Stratified Bootstrap"
format: html
execute:
  echo: true
  warning: false
  message: false
  cache: true
---

```{r setup}
library(tidyverse)
library(knitr)
library(kableExtra)
library(boot)
```

# Load Prepared Data

```{r load-data}
load("results/prepared_data.RData")

# Analytical sample: Protest vs Post-NSL only
hk5_analysis <- hk5 |>
  filter(period %in% c("Protest", "Post-NSL")) |>
  mutate(period = droplevels(period))

cat("Protest:", sum(hk5_analysis$period == "Protest"),
    "| Post-NSL:", sum(hk5_analysis$period == "Post-NSL"), "\n")
```

# 1. Mann-Whitney U Tests

Cross-validate the parametric t-tests with non-parametric Wilcoxon rank-sum
(Mann-Whitney U) tests. This guards against violations of normality assumptions,
which are plausible given that many trust indicators are measured on short
ordinal scales (1–4).

```{r mann-whitney}
# Variables used in the main NSL comparison
nsl_vars <- c(
  # Democratic evaluation
  "democracy_suitability", "dem_extent_current", "dem_country_present_govt",
  # Democratic commitment
  "dem_always_preferable", "democracy_satisfaction",
  # Institutional trust
  "trust_national_government", "trust_president", "trust_parliament",
  "trust_police", "trust_military", "trust_courts",
  # Governance perceptions
  "gov_free_to_organize", "dem_free_speech", "govt_responds_people",
  "election_free_fair",
  # System support
  "system_deserves_support", "system_proud", "system_needs_change",
  # Authoritarian alternatives
  "strongman_rule", "military_rule", "single_party_rule"
)
nsl_vars <- nsl_vars[nsl_vars %in% names(hk5_analysis)]

# Run both t-tests and Mann-Whitney U for each variable
mw_results <- map_dfr(nsl_vars, function(var) {
  protest <- hk5_analysis |> filter(period == "Protest") |> pull(!!sym(var)) |> na.omit()
  postnsl <- hk5_analysis |> filter(period == "Post-NSL") |> pull(!!sym(var)) |> na.omit()

  if (length(protest) < 10 | length(postnsl) < 10) return(NULL)

  # Parametric t-test
  tt <- t.test(protest, postnsl)

  # Non-parametric Mann-Whitney U
  wt <- wilcox.test(protest, postnsl, exact = FALSE)

  # Cohen's d
  pooled_sd <- sqrt(((length(protest) - 1) * sd(protest)^2 +
                       (length(postnsl) - 1) * sd(postnsl)^2) /
                      (length(protest) + length(postnsl) - 2))
  d <- (mean(postnsl) - mean(protest)) / pooled_sd

  tibble(
    variable = var,
    protest_mean = mean(protest),
    postnsl_mean = mean(postnsl),
    cohens_d = d,
    t_stat = tt$statistic,
    t_p = tt$p.value,
    t_sig = case_when(tt$p.value < 0.001 ~ "***",
                      tt$p.value < 0.01  ~ "**",
                      tt$p.value < 0.05  ~ "*",
                      TRUE ~ ""),
    mw_stat = wt$statistic,
    mw_p = wt$p.value,
    mw_sig = case_when(wt$p.value < 0.001 ~ "***",
                       wt$p.value < 0.01  ~ "**",
                       wt$p.value < 0.05  ~ "*",
                       TRUE ~ ""),
    agree = (t_sig == mw_sig) | (tt$p.value < 0.05 & wt$p.value < 0.05)
  )
})

mw_results |>
  select(variable, cohens_d, t_p, t_sig, mw_p, mw_sig, agree) |>
  mutate(across(c(cohens_d), ~round(.x, 3)),
         t_p = format.pval(t_p, digits = 3),
         mw_p = format.pval(mw_p, digits = 3)) |>
  kable(
    col.names = c("Variable", "Cohen's d", "t p-value", "", "MW p-value", "", "Agree?"),
    caption = "Parametric (t-test) vs Non-parametric (Mann-Whitney U) comparison",
    booktabs = TRUE
  ) |>
  kable_styling(latex_options = c("scale_down", "hold_position"))
```

```{r mw-summary}
n_vars <- nrow(mw_results)
n_agree <- sum(mw_results$agree)
cat("Agreement between t-test and Mann-Whitney U:", n_agree, "of", n_vars, "variables",
    paste0("(", round(100 * n_agree / n_vars, 1), "%)\n"))

# Flag any variables where conclusions diverge
divergent <- mw_results |> filter(!agree)
if (nrow(divergent) > 0) {
  cat("\nDivergent results:\n")
  print(divergent |> select(variable, cohens_d, t_p, mw_p))
} else {
  cat("No divergent results: parametric and non-parametric tests yield consistent conclusions.\n")
}
```


# 2. Demographic Balance Across Periods

Assess whether compositional selection drives the observed attitudinal shifts
by comparing the demographic profile of the Protest and Post-NSL sub-samples.

```{r demographic-balance}
# --- Age ---
age_balance <- hk5_analysis |>
  filter(!is.na(age)) |>
  group_by(period) |>
  summarise(
    mean_age = mean(age, na.rm = TRUE),
    sd_age = sd(age, na.rm = TRUE),
    n = n(),
    .groups = "drop"
  )

age_test <- t.test(age ~ period, data = hk5_analysis)
age_mw <- wilcox.test(age ~ period, data = hk5_analysis, exact = FALSE)

cat("=== Age ===\n")
print(age_balance)
cat("t-test p =", format.pval(age_test$p.value, digits = 3),
    "| MW p =", format.pval(age_mw$p.value, digits = 3), "\n\n")

# --- Age group distribution ---
age_group_table <- hk5_analysis |>
  filter(!is.na(age_group)) |>
  count(period, age_group) |>
  group_by(period) |>
  mutate(prop = n / sum(n)) |>
  ungroup()

age_chi <- chisq.test(table(hk5_analysis$period, hk5_analysis$age_group))

cat("=== Age Group Distribution ===\n")
age_group_table |>
  select(-n) |>
  pivot_wider(names_from = period, values_from = prop) |>
  mutate(across(where(is.numeric), ~round(.x, 3))) |>
  kable(caption = "Age group proportions by period") |>
  print()
cat("Chi-squared p =", format.pval(age_chi$p.value, digits = 3), "\n\n")

# --- Gender ---
if ("female" %in% names(hk5_analysis)) {
  gender_table <- hk5_analysis |>
    filter(!is.na(female)) |>
    count(period, female) |>
    group_by(period) |>
    mutate(prop = n / sum(n)) |>
    ungroup()

  gender_chi <- chisq.test(table(hk5_analysis$period, hk5_analysis$female))

  cat("=== Gender ===\n")
  gender_table |>
    select(-n) |>
    pivot_wider(names_from = period, values_from = prop) |>
    mutate(across(where(is.numeric), ~round(.x, 3))) |>
    kable(caption = "Gender proportions by period") |>
    print()
  cat("Chi-squared p =", format.pval(gender_chi$p.value, digits = 3), "\n\n")
} else if ("gender" %in% names(hk5_analysis)) {
  gender_table <- hk5_analysis |>
    filter(!is.na(gender)) |>
    count(period, gender) |>
    group_by(period) |>
    mutate(prop = n / sum(n)) |>
    ungroup()

  gender_chi <- chisq.test(table(hk5_analysis$period, hk5_analysis$gender))

  cat("=== Gender ===\n")
  gender_table |>
    select(-n) |>
    pivot_wider(names_from = period, values_from = prop) |>
    mutate(across(where(is.numeric), ~round(.x, 3))) |>
    kable(caption = "Gender proportions by period") |>
    print()
  cat("Chi-squared p =", format.pval(gender_chi$p.value, digits = 3), "\n\n")
}

# --- Education ---
# Determine which education variable to use: education_level (SE5, ordinal 1-10),
# education_years (continuous), or generic "education"
edu_var <- NULL
if ("education_level" %in% names(hk5_analysis)) {
  # Clean education_level: recode 97/98/99/11/-1 to NA
  hk5_analysis <- hk5_analysis |>
    mutate(
      education_level_clean = case_when(
        education_level %in% c(-1, 11, 97, 98, 99) ~ NA_real_,
        TRUE ~ as.numeric(education_level)
      )
    )
  if (sum(!is.na(hk5_analysis$education_level_clean)) > 100) {
    edu_var <- "education_level_clean"
  }
}
if (is.null(edu_var) && "education_years" %in% names(hk5_analysis) &&
    sum(!is.na(hk5_analysis$education_years)) > 100) {
  edu_var <- "education_years"
}
if (is.null(edu_var) && "education" %in% names(hk5_analysis) &&
    sum(!is.na(hk5_analysis$education)) > 100) {
  edu_var <- "education"
}

edu_test <- NULL
if (!is.null(edu_var)) {
  edu_balance <- hk5_analysis |>
    filter(!is.na(!!sym(edu_var))) |>
    group_by(period) |>
    summarise(
      mean_edu = mean(!!sym(edu_var), na.rm = TRUE),
      sd_edu = sd(!!sym(edu_var), na.rm = TRUE),
      n = n(),
      .groups = "drop"
    )

  edu_test <- t.test(as.formula(paste(edu_var, "~ period")), data = hk5_analysis)
  edu_mw <- wilcox.test(as.formula(paste(edu_var, "~ period")),
                        data = hk5_analysis, exact = FALSE)

  cat("=== Education (", edu_var, ") ===\n")
  print(edu_balance)
  cat("t-test p =", format.pval(edu_test$p.value, digits = 3),
      "| MW p =", format.pval(edu_mw$p.value, digits = 3), "\n\n")
} else {
  cat("=== Education: no suitable variable found ===\n")
}
```

```{r balance-summary-table}
# Compile a clean balance table for manuscript appendix
balance_rows <- list()

# Age (continuous)
balance_rows$age <- tibble(
  covariate = "Age (mean)",
  protest = age_balance$mean_age[age_balance$period == "Protest"],
  postnsl = age_balance$mean_age[age_balance$period == "Post-NSL"],
  test = "t-test",
  p_value = age_test$p.value
)

# Gender (if available)
if ("female" %in% names(hk5_analysis)) {
  fem_prop <- hk5_analysis |>
    filter(!is.na(female)) |>
    group_by(period) |>
    summarise(prop_female = mean(female, na.rm = TRUE), .groups = "drop")
  balance_rows$gender <- tibble(
    covariate = "Female (%)",
    protest = fem_prop$prop_female[fem_prop$period == "Protest"] * 100,
    postnsl = fem_prop$prop_female[fem_prop$period == "Post-NSL"] * 100,
    test = "Chi-squared",
    p_value = gender_chi$p.value
  )
} else if ("gender" %in% names(hk5_analysis)) {
  # Adapt if gender is coded differently
  gender_summary <- hk5_analysis |>
    filter(!is.na(gender)) |>
    group_by(period) |>
    summarise(modal_gender = names(sort(table(gender), decreasing = TRUE))[1],
              .groups = "drop")
  balance_rows$gender <- tibble(
    covariate = "Gender distribution",
    protest = NA_real_,
    postnsl = NA_real_,
    test = "Chi-squared",
    p_value = gender_chi$p.value
  )
}

# Education (using whichever variable was found above)
if (!is.null(edu_test)) {
  edu_label <- ifelse(edu_var == "education_level_clean",
                      "Education level (SE5, ordinal 1-10)",
                      ifelse(edu_var == "education_years",
                             "Education (years)",
                             "Education (mean)"))
  balance_rows$edu <- tibble(
    covariate = edu_label,
    protest = edu_balance$mean_edu[edu_balance$period == "Protest"],
    postnsl = edu_balance$mean_edu[edu_balance$period == "Post-NSL"],
    test = "t-test",
    p_value = edu_test$p.value
  )
}

# Age group distribution
balance_rows$age_group <- tibble(
  covariate = "Age group distribution",
  protest = NA_real_,
  postnsl = NA_real_,
  test = "Chi-squared",
  p_value = age_chi$p.value
)

balance_table <- bind_rows(balance_rows) |>
  mutate(
    across(c(protest, postnsl), ~round(.x, 2)),
    p_value = format.pval(p_value, digits = 3),
    sig = case_when(
      as.numeric(gsub("<", "", p_value)) < 0.001 ~ "***",
      as.numeric(gsub("<", "", p_value)) < 0.01  ~ "**",
      as.numeric(gsub("<", "", p_value)) < 0.05  ~ "*",
      TRUE ~ ""
    )
  )

balance_table |>
  kable(
    col.names = c("Covariate", "Protest", "Post-NSL", "Test", "p-value", ""),
    caption = "Demographic balance across fieldwork periods",
    booktabs = TRUE
  ) |>
  kable_styling(latex_options = c("hold_position"))
```


# 3. Stratified Percentile Bootstrap

Resample independently within each period to preserve the quasi-experimental
structure. Report BCa 95% confidence intervals for the mean difference
(Post-NSL − Protest) and Cohen's d for each variable.

```{r bootstrap}
set.seed(42)
n_boot <- 5000

# --- Parallel setup ---
require_pkg <- function(pkg) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    stop(
      "Package '", pkg, "' is required for the bootstrap section. ",
      "Install it with install.packages('", pkg, "') and re-run."
    )
  }
}
require_pkg("future")
require_pkg("furrr")
library(future)
library(furrr)

n_cores <- max(1L, parallel::detectCores(logical = FALSE) - 1L)
plan(multisession, workers = n_cores)
cat("Bootstrap running on", n_cores, "parallel workers\n")

# Function to compute mean difference for a single variable
# Stratified bootstrap for a single variable (self-contained for worker export)
boot_stratified <- function(var, data, R, seed_offset = 0L) {
  library(boot)
  set.seed(42L + seed_offset)

  protest_vals <- data[data$period == "Protest" & !is.na(data[[var]]), var, drop = TRUE]
  postnsl_vals <- data[data$period == "Post-NSL" & !is.na(data[[var]]), var, drop = TRUE]

  if (length(protest_vals) < 10 | length(postnsl_vals) < 10) return(NULL)

  sub <- data[!is.na(data[[var]]), ]
  strata_int <- as.integer(factor(sub$period))

  boot_mean_diff_local <- function(d, i, v) {
    bd <- d[i, ]
    mean(bd[[v]][bd$period == "Post-NSL"], na.rm = TRUE) -
      mean(bd[[v]][bd$period == "Protest"], na.rm = TRUE)
  }

  boot_cohens_d_local <- function(d, i, v) {
    bd <- d[i, ]
    p <- bd[[v]][bd$period == "Protest"]; p <- p[!is.na(p)]
    q <- bd[[v]][bd$period == "Post-NSL"]; q <- q[!is.na(q)]
    if (length(p) < 5 | length(q) < 5) return(NA_real_)
    ps <- sqrt(((length(p)-1)*sd(p)^2 + (length(q)-1)*sd(q)^2) / (length(p)+length(q)-2))
    if (ps == 0) return(NA_real_)
    (mean(q) - mean(p)) / ps
  }

  boot_diff <- boot(data = sub, statistic = boot_mean_diff_local, R = R,
                    strata = strata_int, v = var)
  boot_d   <- boot(data = sub, statistic = boot_cohens_d_local, R = R,
                    strata = strata_int, v = var)

  extract_ci <- function(b) {
    ci <- tryCatch(boot.ci(b, type = "bca", conf = 0.95),
                   error = function(e) tryCatch(boot.ci(b, type = "perc", conf = 0.95),
                                                error = function(e2) NULL))
    if (!is.null(ci$bca))     return(list(lo = ci$bca[4], hi = ci$bca[5], type = "BCa"))
    if (!is.null(ci$percent)) return(list(lo = ci$percent[4], hi = ci$percent[5], type = "Percentile"))
    list(lo = NA_real_, hi = NA_real_, type = "Failed")
  }

  ci_diff <- extract_ci(boot_diff)
  ci_d    <- extract_ci(boot_d)

  tibble::tibble(
    variable     = var,
    observed_diff = boot_diff$t0,
    boot_diff_lo  = ci_diff$lo,
    boot_diff_hi  = ci_diff$hi,
    observed_d    = boot_d$t0,
    boot_d_lo     = ci_d$lo,
    boot_d_hi     = ci_d$hi,
    ci_type       = ci_diff$type,
    sig_boot      = !(ci_diff$lo <= 0 & ci_diff$hi >= 0)
  )
}

# Run bootstrap in parallel across variables
tstart <- Sys.time()
boot_results <- future_map_dfr(
  seq_along(nsl_vars),
  function(i) boot_stratified(nsl_vars[i], data = hk5_analysis, R = n_boot, seed_offset = i),
  .options = furrr_options(seed = TRUE),
  .progress = TRUE
)
tend <- Sys.time()
cat("Bootstrap completed in", round(difftime(tend, tstart, units = "secs"), 1), "seconds\n")

# Reset to sequential
plan(sequential)
```

```{r bootstrap-table}
boot_results |>
  mutate(across(where(is.numeric), ~round(.x, 3))) |>
  kable(
    col.names = c("Variable", "Obs. Diff", "Diff CI Lo", "Diff CI Hi",
                   "Obs. d", "d CI Lo", "d CI Hi", "CI Type", "Sig?"),
    caption = "Stratified bootstrap results (5,000 iterations): BCa 95% confidence intervals",
    booktabs = TRUE
  ) |>
  kable_styling(latex_options = c("scale_down", "hold_position"))
```

```{r bootstrap-summary}
n_sig <- sum(boot_results$sig_boot, na.rm = TRUE)
n_total <- nrow(boot_results)
cat("Bootstrap significance:", n_sig, "of", n_total, "variables have CIs excluding zero",
    paste0("(", round(100 * n_sig / n_total, 1), "%)\n"))

# Highlight trust variables specifically
trust_boot <- boot_results |>
  filter(str_detect(variable, "trust"))
cat("\nTrust variable bootstrap CIs:\n")
trust_boot |>
  select(variable, observed_d, boot_d_lo, boot_d_hi, sig_boot) |>
  mutate(across(where(is.numeric), ~round(.x, 3))) |>
  print()
```

```{r}
#| label: fig-bootstrap-forest
#| fig-cap: "Stratified bootstrap 95% BCa confidence intervals for Cohen's d (Post-NSL − Protest). Positive values indicate higher post-NSL responses. Variables where the CI excludes zero are shown in colour."
#| fig-width: 10
#| fig-height: 8

boot_results |>
  mutate(
    variable = str_replace_all(variable, "_", " ") |> str_to_title(),
    sig_label = ifelse(sig_boot, "Significant", "Not significant")
  ) |>
  ggplot(aes(x = observed_d, y = reorder(variable, observed_d), color = sig_label)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey50") +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = boot_d_lo, xmax = boot_d_hi), height = 0.25) +
  scale_color_manual(values = c("Significant" = "#E53935", "Not significant" = "#9E9E9E")) +
  labs(
    x = "Cohen's d (Post-NSL − Protest)",
    y = NULL,
    color = NULL
  ) +
  theme_minimal(base_size = 11) +
  theme(legend.position = "bottom")
```


# 4. Age-Stratified Pre/Post Shifts

Faceted bar chart showing the pre/post shift within each age cohort for key
variables. This addresses whether the trust increase is driven entirely by
older cohorts (compositional) or appears across all age groups (more consistent
with falsification).

```{r}
#| label: fig-age-stratified
#| fig-cap: "Pre/Post NSL mean shifts within age cohorts for trust in police and democracy suitability. Error bars show 95% confidence intervals."
#| fig-width: 12
#| fig-height: 7

age_strat_vars <- c("trust_police", "democracy_suitability", 
                     "trust_national_government", "gov_free_to_organize")

age_strat_labels <- c(
  trust_police = "Trust in Police",
  democracy_suitability = "Democracy Suitability",
  trust_national_government = "Trust in Government",
  gov_free_to_organize = "Freedom to Organize"
)

age_strat_data <- hk5_analysis |>
  filter(!is.na(age_group)) |>
  pivot_longer(cols = all_of(age_strat_vars), names_to = "variable", values_to = "value") |>
  filter(!is.na(value)) |>
  group_by(variable, period, age_group) |>
  summarise(
    mean = mean(value),
    se = sd(value) / sqrt(n()),
    n = n(),
    .groups = "drop"
  ) |>
  mutate(var_label = age_strat_labels[variable])

ggplot(age_strat_data, aes(x = age_group, y = mean, fill = period)) +
  geom_col(position = position_dodge(0.8), width = 0.7, alpha = 0.85) +
  geom_errorbar(aes(ymin = mean - 1.96 * se, ymax = mean + 1.96 * se),
                position = position_dodge(0.8), width = 0.25) +
  facet_wrap(~var_label, scales = "free_y", ncol = 2) +
  scale_fill_manual(values = c("Protest" = "#FF7043", "Post-NSL" = "#5C6BC0")) +
  labs(
    x = "Age Cohort", y = "Mean", fill = NULL,
    title = "Pre/Post NSL Shifts Within Age Cohorts"
  ) +
  theme_minimal(base_size = 11) +
  theme(legend.position = "bottom",
        axis.text.x = element_text(angle = 45, hjust = 1))
```


# 5. Informal Manski-Style Bounds

Worst-case bounding exercise: if all non-respondents in the post-NSL period
would have reported the minimum possible trust score, what would the adjusted
mean be? This provides a lower bound on the trust increase.

```{r manski-bounds}
# Generalized Manski bounds function for any trust variable
# R2 requested: extend bounds to at least trust_national_government in addition to police

compute_manski_bounds <- function(data, var, var_label, min_score = 1) {
  protest_vals <- data |>
    filter(period == "Protest", !is.na(!!sym(var))) |>
    pull(!!sym(var))
  postnsl_vals <- data |>
    filter(period == "Post-NSL", !is.na(!!sym(var))) |>
    pull(!!sym(var))

  observed_postnsl_mean <- mean(postnsl_vals)
  observed_protest_mean <- mean(protest_vals)

  scenarios <- tibble(pct_missing_critics = seq(0, 40, by = 5)) |>
    mutate(
      variable = var_label,
      n_observed = length(postnsl_vals),
      n_missing = round(n_observed * pct_missing_critics / 100),
      adjusted_mean = (sum(postnsl_vals) + n_missing * min_score) / (n_observed + n_missing),
      protest_mean = observed_protest_mean,
      trust_still_higher = adjusted_mean > observed_protest_mean
    )

  scenarios
}

# Trust in police
manski_police <- compute_manski_bounds(hk5_analysis, "trust_police", "Trust in Police")

# Trust in national government (R2 requested expansion)
manski_govt <- compute_manski_bounds(hk5_analysis, "trust_national_government",
                                      "Trust in Nat'l Government")

# Combine
manski_scenarios <- bind_rows(manski_police, manski_govt)

# Display trust in police
manski_police |>
  mutate(across(c(adjusted_mean, protest_mean), ~round(.x, 3))) |>
  select(pct_missing_critics, n_observed, n_missing, adjusted_mean, trust_still_higher) |>
  kable(
    col.names = c("% Missing Critics", "N Observed", "N Missing (imputed)",
                   "Adjusted Post-NSL Mean", "Still > Protest Mean?"),
    caption = paste0("Manski-style worst-case bounds for TRUST IN POLICE. ",
                     "Protest mean = ", round(manski_police$protest_mean[1], 3),
                     "; Observed post-NSL mean = ",
                     round(mean(hk5_analysis$trust_police[hk5_analysis$period == "Post-NSL"], na.rm = TRUE), 3)),
    booktabs = TRUE
  ) |>
  kable_styling(latex_options = c("hold_position"))

cat("\nTrust in police: increase disappears at approximately",
    manski_police |> filter(!trust_still_higher) |> slice_min(pct_missing_critics) |> pull(pct_missing_critics),
    "% missing critics.\n")

# Display trust in national government
manski_govt |>
  mutate(across(c(adjusted_mean, protest_mean), ~round(.x, 3))) |>
  select(pct_missing_critics, n_observed, n_missing, adjusted_mean, trust_still_higher) |>
  kable(
    col.names = c("% Missing Critics", "N Observed", "N Missing (imputed)",
                   "Adjusted Post-NSL Mean", "Still > Protest Mean?"),
    caption = paste0("Manski-style worst-case bounds for TRUST IN NATIONAL GOVERNMENT. ",
                     "Protest mean = ", round(manski_govt$protest_mean[1], 3),
                     "; Observed post-NSL mean = ",
                     round(mean(hk5_analysis$trust_national_government[hk5_analysis$period == "Post-NSL"], na.rm = TRUE), 3)),
    booktabs = TRUE
  ) |>
  kable_styling(latex_options = c("hold_position"))

cat("\nTrust in national government: increase disappears at approximately",
    manski_govt |> filter(!trust_still_higher) |> slice_min(pct_missing_critics) |> pull(pct_missing_critics),
    "% missing critics.\n")
```


# 6. MNAR Tipping-Point Bounds for High-Missing Items

For items with substantial item-level missingness (e.g., democracy_suitability at
~60% missing), the Manski-style bounds above are insufficient because they address
non-response to the survey as a whole rather than item-specific MNAR. This section
assumes some fraction of the *missing* responses within each period would have
answered at the minimum score (worst-case "critics") and finds the tipping point
where the observed Post-NSL − Protest difference flips sign.

```{r mnar-function}
# MNAR tipping-point bounds for high-missing items (e.g., democracy_suitability 1-10)
# Idea: assume some fraction of the *missing* responses in a period would have answered
# at the minimum score (worst-case "critics"). Compute adjusted means and the
# adjusted Post-NSL − Protest difference. Find where the sign flips.

compute_mnar_tipping_bounds <- function(
  data,
  var,
  var_label,
  min_score,
  max_score = NULL,
  pct_seq = seq(0, 100, by = 5),
  worst_case = c("post_only", "both")
) {
  worst_case <- match.arg(worst_case)

  # Helper: restrict to the two periods
  d <- data |>
    dplyr::filter(period %in% c("Protest", "Post-NSL")) |>
    dplyr::mutate(period = droplevels(period))

  # Observed values by period
  protest_obs <- d |>
    dplyr::filter(period == "Protest") |>
    dplyr::pull(!!rlang::sym(var))
  post_obs <- d |>
    dplyr::filter(period == "Post-NSL") |>
    dplyr::pull(!!rlang::sym(var))

  # Counts: observed and missing (within-period)
  n_protest_total <- sum(d$period == "Protest")
  n_post_total    <- sum(d$period == "Post-NSL")

  n_protest_obs <- sum(!is.na(protest_obs))
  n_post_obs    <- sum(!is.na(post_obs))

  n_protest_miss <- n_protest_total - n_protest_obs
  n_post_miss    <- n_post_total - n_post_obs

  # Observed means
  protest_mean_obs <- mean(protest_obs, na.rm = TRUE)
  post_mean_obs    <- mean(post_obs, na.rm = TRUE)
  diff_obs         <- post_mean_obs - protest_mean_obs

  # Infer max if not provided (useful when var has odd coding)
  if (is.null(max_score)) {
    max_score <- max(d[[var]], na.rm = TRUE)
  }

  # Build scenarios
  scenarios <- tibble::tibble(pct_missing_critics = pct_seq) |>
    dplyr::mutate(
      variable = var_label,

      # Store period counts as columns
      n_post_total = .env$n_post_total,
      n_post_obs = .env$n_post_obs,
      n_post_miss = .env$n_post_miss,
      n_protest_total = .env$n_protest_total,
      n_protest_obs = .env$n_protest_obs,
      n_protest_miss = .env$n_protest_miss,

      # number of missing we push to minimum in each period
      n_post_critics = round(n_post_miss * pct_missing_critics / 100),

      n_protest_critics = dplyr::case_when(
        worst_case == "post_only" ~ 0L,
        worst_case == "both"      ~ round(n_protest_miss * pct_missing_critics / 100)
      ),

      # Store observed means as columns
      protest_mean_obs = .env$protest_mean_obs,
      post_mean_obs = .env$post_mean_obs,
      diff_obs = .env$diff_obs,

      # adjusted means: observed sum + (critics * min_score) + (remaining missing * assumed mean)
      # For a simple/worst-case bound, treat remaining missing as "like observed mean".
      post_adj_mean = {
        post_sum <- sum(post_obs, na.rm = TRUE)
        n_like_obs <- n_post_miss - n_post_critics
        (post_sum + n_post_critics * min_score + n_like_obs * .env$post_mean_obs) / n_post_total
      },

      protest_adj_mean = {
        protest_sum <- sum(protest_obs, na.rm = TRUE)
        n_like_obs <- n_protest_miss - n_protest_critics
        (protest_sum + n_protest_critics * min_score + n_like_obs * .env$protest_mean_obs) / n_protest_total
      },

      adj_diff = post_adj_mean - protest_adj_mean,

      flips_sign = (sign(adj_diff) != sign(diff_obs)) | (adj_diff == 0),

      notes = dplyr::case_when(
        worst_case == "post_only" ~ "Only Post-NSL missing shifted to minimum (one-sided worst-case)",
        worst_case == "both"      ~ "Both periods' missing shifted to minimum (symmetric stress test)"
      )
    ) |>
    dplyr::select(all_of(c("variable", "pct_missing_critics",
                  "n_post_total", "n_post_obs", "n_post_miss", "n_post_critics",
                  "n_protest_total", "n_protest_obs", "n_protest_miss", "n_protest_critics",
                  "protest_mean_obs", "post_mean_obs", "diff_obs",
                  "protest_adj_mean", "post_adj_mean", "adj_diff", "flips_sign", "notes")))

  # Compute tipping point (smallest pct where sign flips or crosses zero)
  tipping <- scenarios |>
    dplyr::filter(flips_sign) |>
    dplyr::slice_min(pct_missing_critics, with_ties = FALSE) |>
    dplyr::pull(pct_missing_critics)

  attr(scenarios, "tipping_point_pct") <- ifelse(length(tipping) == 0, NA_real_, tipping)
  attr(scenarios, "diff_obs") <- diff_obs
  attr(scenarios, "protest_mean_obs") <- protest_mean_obs
  attr(scenarios, "post_mean_obs") <- post_mean_obs
  attr(scenarios, "min_score") <- min_score
  attr(scenarios, "max_score") <- max_score
  scenarios
}
```

```{r mnar-suitability}
# Democracy suitability (1–10; 10 = completely suitable)
mnar_suitability_postonly <- compute_mnar_tipping_bounds(
  hk5_analysis,
  var = "democracy_suitability",
  var_label = "Democracy Suitability (1–10)",
  min_score = 1,
  max_score = 10,
  pct_seq = seq(0, 100, by = 5),
  worst_case = "post_only"
)

mnar_suitability_both <- compute_mnar_tipping_bounds(
  hk5_analysis,
  var = "democracy_suitability",
  var_label = "Democracy Suitability (1–10)",
  min_score = 1,
  max_score = 10,
  pct_seq = seq(0, 100, by = 5),
  worst_case = "both"
)

cat("Tipping point (post-only):",
    attr(mnar_suitability_postonly, "tipping_point_pct"), "%\n")
cat("Tipping point (both-periods):",
    attr(mnar_suitability_both, "tipping_point_pct"), "%\n")
```

```{r mnar-satisfaction}
# Democratic satisfaction (1–4; 4 = highest)
mnar_satisfaction_postonly <- compute_mnar_tipping_bounds(
  hk5_analysis,
  var = "democracy_satisfaction",
  var_label = "Democracy Satisfaction (1–4)",
  min_score = 1,
  max_score = 4,
  pct_seq = seq(0, 100, by = 5),
  worst_case = "post_only"
)

cat("Tipping point (post-only):",
    attr(mnar_satisfaction_postonly, "tipping_point_pct"), "%\n")
```

```{r mnar-table}
mnar_suitability_postonly |>
  dplyr::mutate(across(c(protest_adj_mean, post_adj_mean, adj_diff), ~round(.x, 3))) |>
  dplyr::select(pct_missing_critics,
                n_post_miss, n_post_critics,
                post_adj_mean,
                n_protest_miss, n_protest_critics,
                protest_adj_mean,
                adj_diff, flips_sign) |>
  knitr::kable(
    col.names = c("% Missing set to min",
                  "Post miss", "Post set-min",
                  "Adj Post mean",
                  "Protest miss", "Protest set-min",
                  "Adj Protest mean",
                  "Adj Diff", "Flip?"),
    caption = paste0(
      "MNAR tipping-point sensitivity: Democracy Suitability (1–10). ",
      "Observed diff = ",
      round(attr(mnar_suitability_postonly, "diff_obs"), 3),
      ". Tipping point = ",
      attr(mnar_suitability_postonly, "tipping_point_pct"),
      "% (post-only)."
    ),
    booktabs = TRUE
  ) |>
  kableExtra::kable_styling(latex_options = c("hold_position"))
```

## 6.1 Extreme-Value MNAR Bounds (Min or Max)

The preceding analysis assumes missing respondents would have answered at the
minimum (worst-case critics). But an alternative "fearful democrats" scenario
is equally plausible: missing Post-NSL respondents may have been strong
supporters of democracy suitability (score = 10) who refused to participate
precisely because they feared revealing pro-democracy views. This function
generalizes the tipping-point analysis to push missing values to either
extreme.

```{r mnar-extreme-function}
# MNAR tipping-point bounds that can push missing values to MIN or MAX
# Useful for high-missing items like democracy_suitability (1-10) or satisfaction (1-4)

compute_mnar_tipping_bounds_extreme <- function(
  data,
  var,
  var_label,
  min_score,
  max_score,
  pct_seq = seq(0, 100, by = 5),
  mode = c("post_missing_to_min", "post_missing_to_max", "both_missing_to_min", "both_missing_to_max")
) {
  mode <- match.arg(mode)

  d <- data |>
    dplyr::filter(period %in% c("Protest", "Post-NSL")) |>
    dplyr::mutate(period = droplevels(period))

  # Pull vectors (may include NA)
  protest_vec <- d |> dplyr::filter(period == "Protest")  |> dplyr::pull(!!rlang::sym(var))
  post_vec    <- d |> dplyr::filter(period == "Post-NSL") |> dplyr::pull(!!rlang::sym(var))

  # Totals by period (including missing)
  n_protest_total <- sum(d$period == "Protest")
  n_post_total    <- sum(d$period == "Post-NSL")

  # Missing counts
  n_protest_miss <- sum(is.na(protest_vec))
  n_post_miss    <- sum(is.na(post_vec))

  # Observed means
  protest_mean_obs <- mean(protest_vec, na.rm = TRUE)
  post_mean_obs    <- mean(post_vec, na.rm = TRUE)
  diff_obs         <- post_mean_obs - protest_mean_obs

  # Observed sums
  protest_sum <- sum(protest_vec, na.rm = TRUE)
  post_sum    <- sum(post_vec, na.rm = TRUE)

  # For "remaining missing", assume they are like observed mean (neutral fill)
  # This keeps the manipulation focused on the "extreme" subset.

  scenarios <- tibble::tibble(pct_missing_extreme = pct_seq) |>
    dplyr::mutate(
      variable = var_label,

      # Store period counts as columns
      n_post_total = .env$n_post_total,
      n_post_miss = .env$n_post_miss,
      n_protest_total = .env$n_protest_total,
      n_protest_miss = .env$n_protest_miss,
      protest_mean_obs = .env$protest_mean_obs,
      post_mean_obs = .env$post_mean_obs,
      diff_obs = .env$diff_obs,

      # How many missing are assigned to extreme value
      n_post_extreme = round(n_post_miss * pct_missing_extreme / 100),
      n_protest_extreme = dplyr::case_when(
        mode %in% c("both_missing_to_min", "both_missing_to_max") ~ round(n_protest_miss * pct_missing_extreme / 100),
        TRUE ~ 0L
      ),

      # Choose extreme value by mode
      post_extreme_value = dplyr::case_when(
        mode %in% c("post_missing_to_min", "both_missing_to_min") ~ min_score,
        TRUE ~ max_score
      ),
      protest_extreme_value = dplyr::case_when(
        mode %in% c("both_missing_to_min") ~ min_score,
        mode %in% c("both_missing_to_max") ~ max_score,
        TRUE ~ NA_real_
      ),

      # Adjusted means
      post_adj_mean = {
        n_like_obs <- n_post_miss - n_post_extreme
        (.env$post_sum + n_post_extreme * post_extreme_value + n_like_obs * .env$post_mean_obs) / n_post_total
      },

      protest_adj_mean = {
        n_like_obs <- n_protest_miss - n_protest_extreme
        (.env$protest_sum +
           n_protest_extreme * dplyr::if_else(is.na(protest_extreme_value), .env$protest_mean_obs, protest_extreme_value) +
           n_like_obs * .env$protest_mean_obs) / n_protest_total
      },

      adj_diff = post_adj_mean - protest_adj_mean,

      # For tipping point, we typically care about the sign relative to the observed sign
      flips_or_crosses_zero = (adj_diff == 0) | (sign(adj_diff) != sign(diff_obs)),

      mode = mode
    ) |>
    dplyr::select(all_of(c("variable", "mode", "pct_missing_extreme",
                  "n_post_total", "n_post_miss", "n_post_extreme", "post_adj_mean",
                  "n_protest_total", "n_protest_miss", "n_protest_extreme", "protest_adj_mean",
                  "protest_mean_obs", "post_mean_obs", "diff_obs",
                  "adj_diff", "flips_or_crosses_zero")))

  tipping <- scenarios |>
    dplyr::filter(flips_or_crosses_zero) |>
    dplyr::slice_min(pct_missing_extreme, with_ties = FALSE) |>
    dplyr::pull(pct_missing_extreme)

  attr(scenarios, "tipping_point_pct") <- ifelse(length(tipping) == 0, NA_real_, tipping)
  attr(scenarios, "diff_obs") <- diff_obs
  scenarios
}
```

```{r mnar-extreme-suitability}
# Fearful democrats scenario: missing Post-NSL respondents are actually MAX (10)
mnar_suitability_post_to_max <- compute_mnar_tipping_bounds_extreme(
  hk5_analysis,
  var = "democracy_suitability",
  var_label = "Democracy Suitability (1–10)",
  min_score = 1,
  max_score = 10,
  pct_seq = seq(0, 100, by = 5),
  mode = "post_missing_to_max"
)

cat("Observed diff = ", round(attr(mnar_suitability_post_to_max, "diff_obs"), 3), "\n")
cat("Tipping point (Post missing -> MAX) = ",
    attr(mnar_suitability_post_to_max, "tipping_point_pct"), "%\n")
```

```{r mnar-extreme-table}
mnar_suitability_post_to_max |>
  dplyr::mutate(across(c(post_adj_mean, protest_adj_mean, adj_diff), ~round(.x, 3))) |>
  dplyr::select(all_of(c("pct_missing_extreme",
                "n_post_miss", "n_post_extreme", "post_adj_mean",
                "n_protest_miss", "protest_adj_mean",
                "adj_diff", "flips_or_crosses_zero"))) |>
  knitr::kable(
    col.names = c("% Post missing set to MAX",
                  "Post miss", "Post set-MAX", "Adj Post mean",
                  "Protest miss", "Adj Protest mean",
                  "Adj Diff", "Flip/cross 0?"),
    caption = paste0(
      "MNAR tipping-point sensitivity: Democracy Suitability (1–10). ",
      "Stress test assumes a share of missing Post-NSL respondents would answer 10. ",
      "Observed diff = ", round(attr(mnar_suitability_post_to_max, "diff_obs"), 3),
      "; tipping point = ", attr(mnar_suitability_post_to_max, "tipping_point_pct"), "%."
    ),
    booktabs = TRUE
  ) |>
  kableExtra::kable_styling(latex_options = c("hold_position"))
```


# 7. Save Results

```{r save-robustness}
save(mw_results, balance_table, boot_results, manski_scenarios,
     mnar_suitability_postonly, mnar_suitability_both, mnar_satisfaction_postonly,
     mnar_suitability_post_to_max,
     file = "results/robustness_results.RData")
cat("Robustness results saved to results/robustness_results.RData\n")
```
